package main

import (
	"fmt"
)

func BinToNum(input string) (num int) {
	l := len(input)
	for i := l - 1; i >= 0; i-- {
		num += (int(input[l-i-1]) - 48) << uint8(i)
	}
	return
}

func NumToBin(input int) (bin string) {
	if input == 0 {
		return "00000000"
	}
	bytez := []byte{48, 48, 48, 48, 48, 48, 48, 48}
	i := len(bytez) - 1
	for ; input > 0; input /= 2 {
		bytez[i] = byte(48 + input%2)
		i--
	}
	bin = string(bytez)
	return
}

func main() {
	str := `
package main

import (
	"fmt"
	"time"
)

//M6Ly9naXRodWIuY29tL2RhcHBsZWRnZXIvQW5uQ2hhaW4vaXNzdWVzLzM3aHR0cH
func main() {
	timeLayout := "2006-01-02"
	timeZhongAn := "2013-10-09"
	timeParse, _ := time.Parse(timeLayout, timeZhongAn)
	result := time.Now().Year() - timeParse.Year()
	fmt.Println(result)
}

`
	result := Encrypt(str)
	fmt.Println(result)
	fmt.Println(Decrypt(result))
}

func Encrypt(str string) (result string) {
	for _, i := range str {
		result += NumToBin(int(i))
	}
	return
}

func Decrypt(str string) (result string) {
	//	str = "0000101001110000011000010110001101101011011000010110011101100101001000000110110101100001011010010110111000001010000010100110100101101101011100000110111101110010011101000010000000101000000010100000100100100010011001100110110101110100001000100000101000001001001000100111010001101001011011010110010100100010000010100010100100001010000010100010111100101111010011010011011001001100011110010011100101101110011000010101100001010010011011110110010001010111010010010111010101011001001100100011100101110100010011000011001001010010011010000110001101001000010000100111001101011010010101110101001001101110010110100101100001001001011101100101000101010111001101010111010101010001001100100110100001101000011000010101011100110100011101100110000101011000010011100111101001100100010101110101011001111010010011000111101001001101001100110110000101001000010100100011000001100011010010000000101001100110011101010110111001100011001000000110110101100001011010010110111000101000001010010010000001111011000010100000100101110100011010010110110101100101010011000110000101111001011011110111010101110100001000000011101000111101001000000010001000110010001100000011000000110110001011010011000000110001001011010011000000110010001000100000101000001001011101000110100101101101011001010101101001101000011011110110111001100111010000010110111000100000001110100011110100100000001000100011001000110000001100010011001100101101001100010011000000101101001100000011100100100010000010100000100101110100011010010110110101100101010100000110000101110010011100110110010100101100001000000101111100100000001110100011110100100000011101000110100101101101011001010010111001010000011000010111001001110011011001010010100001110100011010010110110101100101010011000110000101111001011011110111010101110100001011000010000001110100011010010110110101100101010110100110100001101111011011100110011101000001011011100010100100001010000010010111001001100101011100110111010101101100011101000010000000111010001111010010000001110100011010010110110101100101001011100100111001101111011101110010100000101001001011100101100101100101011000010111001000101000001010010010000000101101001000000111010001101001011011010110010101010000011000010111001001110011011001010010111001011001011001010110000101110010001010000010100100001010000010010110011001101101011101000010111001010000011100100110100101101110011101000110110001101110001010000111001001100101011100110111010101101100011101000010100100001010011111010000101000001010"
	if len(str)%8 != 0 {
		return "invalid input"
	}
	var bytez []byte
	for i := 0; i < len(str)/8; i++ {
		bytez = append(bytez, byte(BinToNum(str[i*8:(i+1)*8])))
	}
	result = string(bytez)
	return
}
